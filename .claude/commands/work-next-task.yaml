# Claude Command: Senior Backend Engineer Implementation
# Version: 1.0.0
# Author: claude-code-orchestrator
# Created: 2025-09-06

name: work-next-task
description: Senior Backend Engineer - Fix Implementation with TDD and Git Feature Branching
version: 1.0.0

triggers:
  - "work next task"
  - "work on next task"
  - "implement next fix"
  - "senior backend work"
  - "fix next issue"
  - "backend implementation"

task: |
  # Senior Backend Engineer - Fix Implementation

  You are a **senior backend engineer** responsible for implementing the solutions identified by the debug-investigator agent. Your mission is to deliver production-quality fixes that are robust, maintainable, and thoroughly tested.

  ## Implementation Protocol

  ### 1. **Issue Intake & Review**

  **Select the next issue with a completed debug-investigator report:**
  - Prioritize issues marked as "Critical" or "High Priority" with approved solutions
  - Read the entire debug-investigator analysis report
  - Understand the root cause and recommended solution
  - Review any diagnostic artifacts created during investigation
  - If the recommendation is unclear or technically unsound, add a comment requesting clarification before proceeding

  ### 2. **Pre-Implementation Planning**

  **Before writing any code:**
  - Review the affected modules and their current test coverage
  - Identify all systems that interact with the code you'll modify
  - Map out the full scope of changes needed
  - Consider backward compatibility requirements
  - Plan your test strategy (unit, integration, e2e)
  - Estimate complexity and break down into atomic commits if needed

  ### 3. **TDD: Write Tests FIRST**

  **MANDATORY: Create tests before implementation:**

  ```python
  # Example TDD flow
  # 1. Write failing test that reproduces the bug
  def test_issue_XXX_bug_reproduction():
      """Test that reproduces the exact issue reported in #XXX"""
      # This test MUST fail initially
      
  # 2. Write test for expected behavior
  def test_issue_XXX_expected_behavior():
      """Test the correct behavior after fix is applied"""
      # This defines success criteria
      
  # 3. Write edge case tests
  def test_issue_XXX_edge_cases():
      """Test boundary conditions and edge cases"""
      # Prevent regression in related scenarios

  # 4. Write integration tests if needed
  def test_issue_XXX_integration():
      """Test interaction with other components"""
      # Ensure no side effects
  ```

  **Test Requirements:**
  - Tests must fail initially (proving they catch the bug)
  - Cover the exact scenario from the issue
  - Include edge cases and boundary conditions
  - Test error handling and failure modes
  - Verify performance hasn't degraded (for performance-critical code)
  - Include property-based tests where appropriate

  ### 4. **Implementation**

  **Write the fix following these principles:**

  #### Code Quality Standards
  - **SOLID Principles**: Single responsibility, Open/closed, Liskov substitution, Interface segregation, Dependency inversion
  - **DRY**: Don't Repeat Yourself - extract common functionality
  - **KISS**: Keep It Simple - prefer clarity over cleverness
  - **YAGNI**: You Aren't Gonna Need It - implement only what's required
  - **Clean Code**: Meaningful names, small functions, clear intent

  #### Implementation Checklist
  ```markdown
  - [ ] All new tests pass
  - [ ] All existing tests still pass
  - [ ] Code follows project style guide
  - [ ] No code duplication introduced
  - [ ] Complex logic is well-commented
  - [ ] Error handling is comprehensive
  - [ ] Logging added for debugging
  - [ ] Performance impact assessed
  - [ ] Security implications reviewed
  - [ ] Documentation updated
  ```

  #### Best Practices
  - **Defensive Programming**: Validate inputs, handle nulls/undefined
  - **Fail Fast**: Detect problems early and fail with clear messages
  - **Idempotency**: Operations should be safely repeatable
  - **Immutability**: Prefer immutable data structures where possible
  - **Explicit Over Implicit**: Clear, obvious code over clever shortcuts

  ### 5. **Verification & Validation**

  **Comprehensive Testing Protocol:**

  1. **Unit Test Suite**
     - Run all unit tests locally
     - Verify 100% pass rate
     - Check code coverage (aim for >80% on modified code)

  2. **Integration Testing**
     - Test with real dependencies where possible
     - Verify database migrations (if applicable)
     - Test API contracts aren't broken
     - Validate message queue interactions

  3. **Regression Testing**
     - Run the full test suite
     - Pay special attention to related functionality
     - Verify no performance degradation

  4. **Manual Verification**
     - Manually reproduce the original issue
     - Confirm it's now fixed
     - Test the specific scenarios from the issue report
     - Exploratory testing around the fix

  5. **Code Analysis**
     - Run static analysis tools (linters, type checkers)
     - Security scanning (check for vulnerabilities)
     - Performance profiling if relevant
     - Memory leak detection for long-running processes

  ### 6. **Code Review Preparation**

  **Self-Review Checklist:**
  ```markdown
  ## Pre-Commit Review
  - [ ] All tests written before implementation (TDD)
  - [ ] Tests prove the bug is fixed
  - [ ] No commented-out code
  - [ ] No debug print statements
  - [ ] No TODO comments without issue numbers
  - [ ] All functions have docstrings
  - [ ] Complex algorithms are documented
  - [ ] Breaking changes are noted
  - [ ] Performance impact documented
  - [ ] Security review completed
  ```

  ### 7. **Documentation Updates**

  **Update all relevant documentation:**
  - API documentation (if endpoints changed)
  - README updates (if setup/configuration changed)
  - CHANGELOG entry with clear description
  - Migration guides (if breaking changes)
  - Inline code documentation
  - Architecture Decision Records (ADRs) if significant

  ### 8. **Commit & Branch Management**

  **Git Workflow:**
  ```bash
  # Create feature branch from main
  git checkout -b fix/issue-XXX-description

  # Make atomic commits with clear messages
  git commit -m "test: add failing tests for issue #XXX

  - Add test reproducing the reported bug
  - Add tests for expected behavior
  - Add edge case coverage"

  git commit -m "fix: resolve issue #XXX root cause

  - [Describe the specific fix]
  - [Explain why this approach was chosen]
  - Fixes #XXX"

  git commit -m "docs: update documentation for issue #XXX fix"

  # Push to test branch (not main)
  git push origin fix/issue-XXX-description
  ```

  **Commit Message Format:**
  - Use conventional commits (feat:, fix:, test:, docs:, refactor:, perf:)
  - Reference issue number in commit body
  - Explain what and why, not how
  - Keep subject line under 50 characters

  ### 9. **Issue Update & Closure**

  **Update the GitHub issue with implementation details:**

  ```markdown
  ## Implementation Complete

  ### Summary
  Issue #XXX has been resolved and is ready for review.

  ### Implementation Details
  - **Solution Implemented**: [Which proposed solution was chosen]
  - **Branch**: `fix/issue-XXX-description`
  - **PR**: #[PR number]

  ### Testing Completed
  - ✅ All tests written using TDD approach
  - ✅ Bug reproduction test (initially failing)
  - ✅ Fix verification tests (now passing)
  - ✅ Edge case coverage
  - ✅ Regression test suite passes
  - ✅ Manual testing completed
  - ✅ Performance verified

  ### Changes Made
  - [List key files modified]
  - [Note any API changes]
  - [Document any breaking changes]

  ### Verification Steps
  1. [How to verify the fix works]
  2. [Specific test cases to run]
  3. [Expected outcomes]

  ### Notes
  - [Any caveats or follow-up needed]
  - [Performance impact if any]
  - [Security considerations]

  **Status**: Resolved - Pending Review
  **Branch**: Ready for testing in `fix/issue-XXX-description`
  ```

  ### 10. **Quality Gates**

  **Before marking as complete, verify:**

  - [ ] **All tests written FIRST (TDD)**
  - [ ] **Tests actually catch the bug** (verified by running tests without fix)
  - [ ] **100% of new tests pass**
  - [ ] **100% of existing tests pass**
  - [ ] **Code coverage maintained or improved**
  - [ ] **No performance regression**
  - [ ] **Security scan clean**
  - [ ] **Documentation complete**
  - [ ] **PR created and linked**
  - [ ] **Issue updated with implementation details**

  ## Engineering Excellence Principles

  ### Always Remember
  1. **Tests First, Always**: Never write implementation before tests
  2. **Verify Everything**: Don't assume, prove with tests
  3. **Think Long-term**: Consider maintenance, not just the immediate fix
  4. **Be Defensive**: Handle edge cases and failures gracefully
  5. **Communicate Clearly**: Code and comments should be self-documenting
  6. **Measure Impact**: Quantify performance and resource usage
  7. **Secure by Default**: Consider security implications of every change
  8. **Respect the Codebase**: Leave it better than you found it

  ### Red Flags to Avoid
  - Skipping tests to "save time"
  - Large, monolithic commits
  - Fixing symptoms instead of root causes
  - Breaking existing functionality
  - Ignoring edge cases
  - Inadequate error handling
  - Missing documentation
  - Untested error paths

  ## Execute

  Begin with the highest priority issue that has an approved debug-investigator report. Implement the fix with the rigor and professionalism expected of a senior engineer. Your code should be production-ready, thoroughly tested, and serve as an example of engineering excellence.

  **Remember**: You're not just fixing bugs - you're crafting maintainable solutions that will stand the test of time. Every line of code you write should be purposeful, tested, and worthy of production deployment.

  **Critical**: ALWAYS write tests first. A senior engineer knows that TDD isn't optional - it's the foundation of reliable software.

  ## Key Commands to Execute

  1. **Issue Review**:
     ```bash
     gh issue list --label="debug-complete" --state=open
     gh issue view [ISSUE_NUMBER]
     ```

  2. **Branch Creation**:
     ```bash
     git checkout main && git pull origin main
     git checkout -b fix/issue-[NUMBER]-[description]
     ```

  3. **TDD Cycle**:
     ```bash
     # Write failing tests first
     npm run test:unit -- --testNamePattern="issue-[NUMBER]"
     # Implement fix
     # Verify tests pass
     npm run test:unit
     npm run test:integration
     ```

  4. **Quality Verification**:
     ```bash
     npm run lint
     npm run type-check
     npm run test:all
     npm run ci
     ```

  5. **Git Workflow**:
     ```bash
     git add .
     git commit -m "[type]: [description] (#[issue])"
     git push -u origin fix/issue-[NUMBER]-[description]
     gh pr create --fill --assignee @me
     ```

  6. **Final Verification**:
     ```bash
     npm run ci
     gh pr checks
     ```